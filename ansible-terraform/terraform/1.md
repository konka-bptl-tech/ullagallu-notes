## âœ… Problems with Provisioning Infra Manually

* For example, we have a simple 3-tier application need to host our application, it requires infrastructure like network, servers, database, volumes, etc.

* To provision infra manually, it is time-consuming and more error-prone. Small misconfigurations can lead to a bunch of errors.

* Managing multiple environments (like dev, staging, prod) manually is hard and error-prone, especially when each one needs different configurations or capacities.

* Manually created infrastructure is not flexible or scalable â€” itâ€™s difficult to quickly adjust size or resources based on demand.

* Not easy to do cost analysis. Manual creation leads to high costs because all resources may keep running until the infra setup is complete.

* You have to manually track and manage all resources, which becomes difficult as the infrastructure grows.

* There's no proper audit trail â€” you canâ€™t see who made changes, when, or what was changed.

---

## ğŸ§¾ IaC (Infrastructure as Code)

* Instead of doing everything manually, why not define our infrastructure as code?

* One big benefit is we can store the code in a Version Control System (VCS) like Git.

* It becomes easy to create the same infrastructure across multiple environments (dev, test, prod).

* We get clear audit history â€” who made changes, what changed, and when.

* It is faster and safer to provision, update, or destroy infrastructure using code.

---

## ğŸ”§ Terraform

* Terraform is one of the popular IaC tools that uses HCL (HashiCorp Configuration Language) to define cloud resources.

* Itâ€™s cloud-agnostic â€” meaning it can create infrastructure across multiple cloud providers, not just one.

* Terraform maintains a state file to keep track of the resources it manages.

* It supports modules, which help make your code reusable and cleaner by passing different values for different use cases.

---

### ğŸ” **Interpolation in Terraform**

**Interpolation** is a way to insert the value of a variable, resource, or expression into a string using `${...}`.

It's like saying:
â¡ï¸ â€œPut this value here inside the string.â€

---

### âœ… **Example**

```hcl
variable "env" {
  default = "dev"
}

output "bucket_name" {
  value = "my-app-${var.env}-bucket"
}
```

#### ğŸ’¬ Explanation:

* `var.env` is `"dev"`.
* `output` will show:
  `"my-app-dev-bucket"`

---

### ğŸ“ Note:

In **newer versions of Terraform**, you can also use simple string formatting:

```hcl
value = "my-app-${var.env}-bucket"     # interpolation syntax
value = "my-app-${var.env}-bucket"     # still works
value = "my-app-${var.env}-bucket"     # all same result
```

You donâ€™t always need `${}` if itâ€™s just a variable:

```hcl
value = "my-app-${var.env}"   # âœ…
value = "my-app-${"dev"}"     # âœ…
value = "my-app-" + var.env   # âœ… also allowed
```
Sure! Here's a **simple explanation of variable types in Terraform** with easy examples â€” perfect for quick learning and revision.

---

## ğŸ“¦ Variable Types in Terraform

---

### 1. **string**

Used for plain text.

```hcl
variable "env" {
  type    = string
  default = "dev"
}
```

âœ… Example use:
`var.env` â†’ `"dev"`

---

### 2. **number**

Used for numeric values (integers or floats).

```hcl
variable "instance_count" {
  type    = number
  default = 3
}
```

âœ… Example use:
`var.instance_count` â†’ `3`

---

### 3. **bool**

Used for true/false values.

```hcl
variable "enable_logging" {
  type    = bool
  default = true
}
```

âœ… Example use:
`var.enable_logging` â†’ `true`

---

### 4. **list**

A list of values (same type).

```hcl
variable "azs" {
  type    = list(string)
  default = ["us-east-1a", "us-east-1b"]
}
```

âœ… Example use:
`var.azs[0]` â†’ `"us-east-1a"`

---

### 5. **map**

Key-value pairs (like a dictionary).

```hcl
variable "instance_types" {
  type = map(string)
  default = {
    dev  = "t2.micro"
    prod = "t3.large"
  }
}
```

âœ… Example use:
`var.instance_types["dev"]` â†’ `"t2.micro"`

---

### 6. **object**

Structured data with named attributes and types.

```hcl
variable "db_config" {
  type = object({
    name     = string
    port     = number
    enabled  = bool
  })
  default = {
    name    = "mydb"
    port    = 5432
    enabled = true
  }
}
```

âœ… Example use:
`var.db_config.name` â†’ `"mydb"`

---

### 7. **tuple**

A list with fixed types and positions.

```hcl
variable "sample_tuple" {
  type = tuple([string, number, bool])
  default = ["abc", 123, true]
}
```

âœ… Example use:
`var.sample_tuple[1]` â†’ `123`

---

### ğŸ”„ Dynamic types (any)

You can also use `type = any` to allow any type of value.

```hcl
variable "flexible_input" {
  type    = any
  default = "hello"
}
```

---

## âš–ï¸ **Terraform Variable Precedence (High â†’ Low)**

| Priority | Source                                 | Example                              |
| -------- | -------------------------------------- | ------------------------------------ |
| 1ï¸âƒ£      | **Command-line `-var` or `-var-file`** | `terraform apply -var="env=prod"`    |
| 2ï¸âƒ£      | **Environment variables** (`TF_VAR_`)  | `export TF_VAR_env=prod`             |
| 3ï¸âƒ£      | **Terraform `.tfvars` files**          | `terraform.tfvars`, `prod.tfvars`    |
| 4ï¸âƒ£      | **Default value in `.tf` file**        | `variable "env" { default = "dev" }` |

---

### ğŸ” Letâ€™s go through each one with examples

---

### 1ï¸âƒ£ **Command Line Variable**

Highest priority â€” overrides all.

```bash
terraform apply -var="env=prod"
```

âœ… Terraform will use `env = "prod"` even if itâ€™s set elsewhere.

---

### 2ï¸âƒ£ **Environment Variable**

```bash
export TF_VAR_env="staging"
```

âœ… Used if no `-var` provided.

---

### 3ï¸âƒ£ **`.tfvars` File**

Create a file called `terraform.tfvars`:

```hcl
env = "test"
```

âœ… Auto-loaded by Terraform.

You can also use custom files:

```bash
terraform apply -var-file="prod.tfvars"
```

---

### 4ï¸âƒ£ **Default Value**

In your Terraform code:

```hcl
variable "env" {
  default = "dev"
}
```

âœ… Used only if no other value is given.

---

### ğŸ§  Example: What Happens?

```hcl
variable "env" {
  default = "dev"
}
```

* You have `terraform.tfvars` â†’ `env = "test"`
* You set `export TF_VAR_env="staging"`
* You run:
  `terraform apply -var="env=prod"`

ğŸ”š **Terraform will use:** `env = "prod"` (because command line overrides all)

---

Here are the **basic Terraform commands** every beginner should know â€” explained simply and clearly:

---

## ğŸ§° **Terraform Basic Commands**

### 1ï¸âƒ£ `terraform init`

* **Initializes** the Terraform project.
* Downloads required providers and modules.

```bash
terraform init
```

---

### 2ï¸âƒ£ `terraform plan`

* **Previews** what changes Terraform will make.
* Does **not** change anything yet.

```bash
terraform plan
```

---

### 3ï¸âƒ£ `terraform apply`

* **Applies** the changes to real infrastructure.
* Creates, updates, or deletes resources.

```bash
terraform apply
```

---

### 4ï¸âƒ£ `terraform destroy`

* **Destroys** all resources created by Terraform.
* Use with caution!

```bash
terraform destroy
```

---

### 5ï¸âƒ£ `terraform validate`

* **Checks** if your configuration files are syntactically correct.

```bash
terraform validate
```

---

### 6ï¸âƒ£ `terraform fmt`

* **Formats** your `.tf` files for better readability.

```bash
terraform fmt
```

---

### 7ï¸âƒ£ `terraform show`

* Shows the **current state** or the output from a plan/apply.

```bash
terraform show
```

---

### 8ï¸âƒ£ `terraform output`

* Displays the values of **output variables**.

```bash
terraform output
```

---

### 9ï¸âƒ£ `terraform state list`

* Lists all the **resources in the current state file**.

```bash
terraform state list
```

---

### ğŸ”Ÿ `terraform version`

* Shows the installed **Terraform version**.

```bash
terraform version
```

---

